<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>obsidian</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 12 Aug 2024 19:42:04 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 12 Aug 2024 19:42:01 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[std::multiset in C++]]></title><description><![CDATA[ 
 <br><br><br>std::multiset is an associative container in the C++ Standard Library that stores multiple instances of equivalent elements in a specific order. It is typically implemented as a balanced binary search tree (such as a Red-Black Tree), which provides efficient management of elements with logarithmic time complexity for insertion, deletion, and search operations.<br><br>
<br>Allows Duplicates: Unlike std::set, std::multiset allows multiple occurrences of equivalent elements.
<br>Sorted Order: Elements are stored in a sorted order based on their values.
<br>Logarithmic Time Complexity: Offers O(log n) complexity for insertion, deletion, and lookup operations.
<br>Iterator Stability: Iterators are stable, meaning they remain valid even after insertions and deletions (except for the deleted element).
<br><br>#include &lt;set&gt;

// Declaration
std::multiset&lt;int&gt; myMultiset;

// Insertion
myMultiset.insert(10);
myMultiset.insert(20);
myMultiset.insert(10); // Duplicate allowed

// Check existence
if (myMultiset.find(10) != myMultiset.end()) {
    // Element found
}

// Deletion
myMultiset.erase(20);

// Iteration
for (const auto&amp; element : myMultiset) {
    std::cout &lt;&lt; element &lt;&lt; " ";
}
Copy<br><br>
<br>insert(const value_type&amp; val): Adds an element to the multiset.
<br>erase(const key_type&amp; key): Removes elements with the specified key.
<br>find(const key_type&amp; key): Searches for the specified key and returns an iterator to the element if found, otherwise returns end().
<br>size(): Returns the number of elements in the multiset.
<br>empty(): Checks if the multiset is empty.
<br>clear(): Removes all elements from the multiset.
<br>begin() / end(): Returns an iterator to the beginning/end of the multiset.
<br>count(const key_type&amp; key): Returns the number of elements with the specified key.
<br>lower_bound(const key_type&amp; key): Returns an iterator pointing to the first element not less than the given key.
<br>upper_bound(const key_type&amp; key): Returns an iterator pointing to the first element greater than the given key.
<br>equal_range(const key_type&amp; key): Returns a pair of iterators that denote the range of elements equivalent to the given key.
<br><br>#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::multiset&lt;int&gt; myMultiset;

    // Insert elements
    myMultiset.insert(1);
    myMultiset.insert(2);
    myMultiset.insert(3);
    myMultiset.insert(3); // Duplicate insertion

    // Check if an element exists
    if (myMultiset.find(3) != myMultiset.end()) {
        std::cout &lt;&lt; "Element 3 found in the multiset." &lt;&lt; std::endl;
    }

    // Count occurrences of an element
    std::cout &lt;&lt; "Occurrences of 3: " &lt;&lt; myMultiset.count(3) &lt;&lt; std::endl;

    // Erase one occurrence of an element
    myMultiset.erase(myMultiset.find(3));

    // Iterate over the elements
    std::cout &lt;&lt; "Elements in the multiset: ";
    for (const int&amp; elem : myMultiset) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Output the size of the multiset
    std::cout &lt;&lt; "Size of the multiset: " &lt;&lt; myMultiset.size() &lt;&lt; std::endl;

    return 0;
}
Copy<br><br>
<br>Counting Elements: Useful for situations where multiple instances of elements are needed, such as counting occurrences.
<br>Sorted Collections: Ideal for scenarios requiring automatic sorting of elements.
<br>Efficient Searching: Provides efficient search operations due to the ordered structure.
<br><br>
<br>Duplicates: std::multiset allows multiple copies of equivalent elements, while std::set does not.
<br>Use Case: Use std::multiset when duplicates are necessary.
<br><br>
<br>Balanced Tree: std::multiset is usually implemented as a Red-Black Tree, ensuring efficient operations.
<br>Iterator Validity: Iterators remain valid across insertions and deletions, except for erased elements.
<br>Automatic Sorting: Automatically sorts elements based on their values, ensuring efficient retrieval.
<br><br>
<br>Logarithmic Complexity: Operations are efficient due to tree balancing but may be slower than std::unordered_multiset for unordered data.
<br>Memory Usage: Tree structure may require more memory compared to hash-based containers.
<br>Sorting: Sorting provides efficiency for ordered data retrieval but may add overhead.
<br><br>std::multiset is a versatile container in C++ for managing collections of elements where duplicates and automatic sorting are needed. Its ordered structure and logarithmic complexity make it suitable for scenarios requiring efficient management and retrieval of duplicate items.]]></description><link>dsa-cpp/multiset.html</link><guid isPermaLink="false">dsa-cpp/multiset.md</guid><pubDate>Sat, 27 Jul 2024 14:17:07 GMT</pubDate></item><item><title><![CDATA[Set]]></title><description><![CDATA[ 
 <br><br>std::set is an associative container in the C++ Standard Library that stores unique elements in a specific order. It is implemented as a balanced binary search tree (typically a Red-Black Tree), ensuring logarithmic time complexity for insertion, deletion, and lookup operations.<br><br>
<br>Unique Elements: Only stores unique elements; duplicates are not allowed.
<br>Sorted Order: Elements are stored in a sorted order based on their values.
<br>Logarithmic Time Complexity: Provides O(log n) complexity for insertion, deletion, and search operations.
<br>Iterator Stability: Iterators to elements are stable, meaning they remain valid even after insertions and deletions (except for the deleted element).
<br><br>#include &lt;set&gt;

// Declaration
std::set&lt;int&gt; mySet;

// Insertion
mySet.insert(10);
mySet.insert(20);

// Check existence
if (mySet.find(10) != mySet.end()) {
    // Element found
}

// Deletion
mySet.erase(20);

// Iteration
for (const auto&amp; element : mySet) {
    std::cout &lt;&lt; element &lt;&lt; " ";
}

Copy<br><br>
<br>insert(const value_type&amp; val): Adds an element to the set.
<br>erase(const key_type&amp; key): Removes the element with the specified key.
<br>find(const key_type&amp; key): Searches for the specified key and returns an iterator to the element if found, otherwise returns end().
<br>size(): Returns the number of elements in the set.
<br>empty(): Checks if the set is empty.
<br>clear(): Removes all elements from the set.
<br>begin() / end(): Returns an iterator to the beginning/end of the set.
<br>count(const key_type&amp; key): Returns 1 if the element with the specified key is found, otherwise returns 0.
<br><br>#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; mySet;

    // Insert elements
    mySet.insert(1);
    mySet.insert(2);
    mySet.insert(3);
    mySet.insert(4);

    // Check if an element exists
    if (mySet.find(2) != mySet.end()) {
        std::cout &lt;&lt; "Element 2 found in the set." &lt;&lt; std::endl;
    }

    // Erase an element
    mySet.erase(3);

    // Iterate over the elements
    std::cout &lt;&lt; "Elements in the set: ";
    for (const int&amp; elem : mySet) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Output the size of the set
    std::cout &lt;&lt; "Size of the set: " &lt;&lt; mySet.size() &lt;&lt; std::endl;

    return 0;
}

Copy<br><br>
<br>Sorted Collections: Use when you need to store a collection of elements that must be sorted automatically.
<br>Unique Elements: Ideal for storing collections of unique items where duplicates are not allowed.
<br>Efficient Searching: Provides efficient searching for elements due to its logarithmic complexity.
<br><br>
<br>Order: std::set stores elements in a sorted order, while std::unordered_set does not guarantee any order.
<br>Underlying Data Structure: std::set uses a balanced binary search tree, whereas std::unordered_set uses a hash table.
<br>Complexity: std::set has O(log n) complexity for operations, while std::unordered_set offers average O(1) complexity.
<br><br>
<br>Balanced Tree: std::set is usually implemented as a Red-Black Tree, ensuring balanced and efficient operations.
<br>Iterator Validity: Inserting or deleting elements doesn't invalidate iterators except for iterators pointing to deleted elements.
<br>Duplicate Handling: Attempts to insert duplicates will be ignored without causing errors.
<br><br>
<br>Logarithmic Complexity: Operations are efficient but can be slower than std::unordered_set for simple lookup operations due to tree balancing.
<br>Memory Usage: May use more memory than std::unordered_set due to tree structure overhead.
<br>Sorted Order: If maintaining order is unnecessary, consider std::unordered_set for better average performance.
<br><br>std::set is a versatile and efficient container in C++ for managing sorted collections of unique elements. Its ordered structure and logarithmic complexity make it suitable for scenarios requiring automatic sorting and efficient searching of unique items.]]></description><link>dsa-cpp/set.html</link><guid isPermaLink="false">dsa-cpp/Set.md</guid><pubDate>Sat, 27 Jul 2024 14:13:52 GMT</pubDate></item><item><title><![CDATA[STL - Standard Template Library]]></title><description><![CDATA[ 
 <br>STL stands for standard template library which contains a lot of pre-defined templates in terms of containers and classes which makes it very easy for developers or programmers to implement different data structures easily without having to write complete code and worry about space-time complexities.<br><a data-href="Unordered-set" href="dsa-cpp/unordered-set.html" class="internal-link" target="_self" rel="noopener">Unordered-set</a> -- stores unique elements in no particular order<br>
<a data-href="Vector" href="dsa-cpp/vector.html" class="internal-link" target="_self" rel="noopener">Vector</a> -- dynamic array<br>
<a data-href="Set" href="dsa-cpp/set.html" class="internal-link" target="_self" rel="noopener">Set</a> -- stores unique elements in a particular order<br>
<a data-href="Unordered_multiset" href="dsa-cpp/unordered_multiset.html" class="internal-link" target="_self" rel="noopener">Unordered_multiset</a> -- when you need to store multiple instances of the same element and count occurrences ; stores multiple copies of equivalent elements without any particular order<br>
<a data-href="multiset" href="dsa-cpp/multiset.html" class="internal-link" target="_self" rel="noopener">multiset</a> -- multiple instances of equivalent elements in a specific order<br>
<a data-href="unordered_map" href="dsa-cpp/unordered_map.html" class="internal-link" target="_self" rel="noopener">unordered_map</a> -- stores elements formed by key-value pairs]]></description><link>dsa-cpp/stl-standard-template-library.html</link><guid isPermaLink="false">dsa-cpp/STL - Standard Template Library.md</guid><pubDate>Sun, 28 Jul 2024 09:28:07 GMT</pubDate></item><item><title><![CDATA[unordered_map]]></title><description><![CDATA[ 
 <br><br>std::unordered_map is an associative container in the C++ Standard Library that stores elements formed by key-value pairs. It is implemented using a hash table, allowing for average constant-time complexity for insertion, deletion, and lookup operations.<br><br>
<br>Key-Value Storage: Stores elements as key-value pairs.
<br>No Specific Order: Elements are not stored in any particular order.
<br>Hashing: Utilizes a hash table for fast access to elements.
<br>Average Constant Time Complexity: Provides O(1) average complexity for insertion, deletion, and search operations. However, in the worst case, operations could degrade to O(n).
<br><br>#include &lt;unordered_map&gt;

// Declaration
std::unordered_map&lt;int, std::string&gt; myMap;

// Insertion
myMap.insert({1, "Apple"});
myMap[2] = "Banana"; // Using the subscript operator

// Access
std::string fruit = myMap[1];

// Check existence
if (myMap.find(2) != myMap.end()) {
    // Key 2 is found
}

// Deletion
myMap.erase(1);

// Iteration
for (const auto&amp; pair : myMap) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; std::endl;
}

Copy<br><br>
<br>insert(const value_type&amp; val): Adds a key-value pair to the map.
<br>erase(const key_type&amp; key): Removes the element with the specified key.
<br>find(const key_type&amp; key): Searches for the specified key and returns an iterator to the element if found, otherwise returns end().
<br>size(): Returns the number of elements in the map.
<br>empty(): Checks if the map is empty.
<br>clear(): Removes all elements from the map.
<br>begin() / end(): Returns an iterator to the beginning/end of the map.
<br>count(const key_type&amp; key): Returns 1 if the element with the specified key is found, otherwise returns 0.
<br>at(const key_type&amp; key): Returns a reference to the value associated with the specified key, with bounds checking.
<br><br>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;

int main() {
    std::unordered_map&lt;std::string, int&gt; fruitPrices;

    // Insert elements
    fruitPrices.insert({"Apple", 100});
    fruitPrices["Banana"] = 50;
    fruitPrices["Cherry"] = 150;

    // Access elements
    std::cout &lt;&lt; "Price of Apple: " &lt;&lt; fruitPrices.at("Apple") &lt;&lt; std::endl;

    // Check if a key exists
    if (fruitPrices.find("Banana") != fruitPrices.end()) {
        std::cout &lt;&lt; "Banana is available." &lt;&lt; std::endl;
    }

    // Erase an element
    fruitPrices.erase("Cherry");

    // Iterate over the elements
    std::cout &lt;&lt; "Fruit prices: " &lt;&lt; std::endl;
    for (const auto&amp; pair : fruitPrices) {
        std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; std::endl;
    }

    // Output the size of the map
    std::cout &lt;&lt; "Number of fruits: " &lt;&lt; fruitPrices.size() &lt;&lt; std::endl;

    return 0;
}

Copy<br><br>
<br>Key-Value Associations: Ideal for storing and managing key-value pairs with fast lookup.
<br>Hash-Based Storage: Suitable for scenarios where the order of elements is not important.
<br>Efficient Searching: Provides quick access to elements using keys.
<br><br>
<br>Order: std::unordered_map does not maintain any specific order of elements, whereas std::map maintains a sorted order based on the key.
<br>Complexity: std::unordered_map provides average O(1) complexity for operations, while std::map provides O(log n) complexity due to its tree-based structure.
<br>Use Case: Use std::unordered_map when order is not important and faster access is needed.
<br><br>
<br>Hash Function: The performance depends on the quality of the hash function used.
<br>Iterator Validity: Inserting elements may invalidate iterators if rehashing occurs.
<br>Bucket Count: Control the number of buckets and load factors for performance tuning using rehash() and reserve().
<br><br>
<br>Load Factor: Monitor and manage the load factor to ensure optimal performance.
<br>Collision Handling: Efficiently handle hash collisions to maintain performance.
<br>Rehashing: Be aware of operations that may trigger rehashing, as it can be costly.
<br><br>std::unordered_map is a powerful and efficient container in C++ for managing collections of key-value pairs where order is not important. Its hash-based structure offers fast average-time operations, making it suitable for applications requiring quick access and management of key-value associations.]]></description><link>dsa-cpp/unordered_map.html</link><guid isPermaLink="false">dsa-cpp/unordered_map.md</guid><pubDate>Sat, 27 Jul 2024 14:18:49 GMT</pubDate></item><item><title><![CDATA[Unordered_multiset]]></title><description><![CDATA[ 
 <br><br>std::unordered_multiset is a C++ Standard Library container that stores multiple copies of equivalent elements without any particular order. It is implemented using a hash table, allowing for average constant-time complexity for insertion, deletion, and lookup operations.<br><br>
<br>Multiple Elements Allowed: Allows multiple instances of equivalent elements, unlike std::unordered_set.
<br>No Order: Elements are not stored in any specific order.
<br>Hashing: Uses a hash table for storage, which provides fast access to elements.
<br>Average Constant Time Complexity: Provides O(1) average complexity for insertion, deletion, and search operations. In the worst case, operations could degrade to O(n).
<br><br>#include &lt;unordered_set&gt;

// Declaration
std::unordered_multiset&lt;int&gt; myMultiset;

// Insertion
myMultiset.insert(10);
myMultiset.insert(20);
myMultiset.insert(10); // Duplicate allowed

// Check existence
if (myMultiset.find(10) != myMultiset.end()) {
    // Element found
}

// Deletion
myMultiset.erase(20);

// Iteration
for (const auto&amp; element : myMultiset) {
    std::cout &lt;&lt; element &lt;&lt; " ";
}

Copy<br><br>
<br>insert(const value_type&amp; val): Adds an element to the multiset.
<br>erase(const key_type&amp; key): Removes elements with the specified key.
<br>find(const key_type&amp; key): Searches for the specified key and returns an iterator to the element if found, otherwise returns end().
<br>size(): Returns the number of elements in the multiset.
<br>empty(): Checks if the multiset is empty.
<br>clear(): Removes all elements from the multiset.
<br>begin() / end(): Returns an iterator to the beginning/end of the multiset.
<br>count(const key_type&amp; key): Returns the number of elements with the specified key.
<br><br>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_multiset&lt;int&gt; myMultiset;

    // Insert elements
    myMultiset.insert(1);
    myMultiset.insert(2);
    myMultiset.insert(3);
    myMultiset.insert(3); // Duplicate insertion

    // Check if an element exists
    if (myMultiset.find(3) != myMultiset.end()) {
        std::cout &lt;&lt; "Element 3 found in the multiset." &lt;&lt; std::endl;
    }

    // Count occurrences of an element
    std::cout &lt;&lt; "Occurrences of 3: " &lt;&lt; myMultiset.count(3) &lt;&lt; std::endl;

    // Erase all occurrences of an element
    myMultiset.erase(3);

    // Iterate over the elements
    std::cout &lt;&lt; "Elements in the multiset: ";
    for (const int&amp; elem : myMultiset) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Output the size of the multiset
    std::cout &lt;&lt; "Size of the multiset: " &lt;&lt; myMultiset.size() &lt;&lt; std::endl;

    return 0;
}

Copy<br><br>
<br>Counting Elements: Useful when you need to store multiple instances of the same element and count occurrences.
<br>Unordered Collections: Ideal for storing collections of elements without a specific order.
<br>Fast Access: Provides efficient access and modification when order is not a concern.
<br><br>
<br>Multiple Copies: std::unordered_multiset allows multiple copies of equivalent elements, while std::unordered_set does not.
<br>Use Case: Use std::unordered_multiset when you need to store duplicate elements and count their occurrences.
<br><br>
<br>Hash Function: The performance depends on the quality of the hash function used.
<br>Iterator Validity: Inserting elements may invalidate iterators if rehashing occurs.
<br>Bucket Count: Control the number of buckets and load factors for performance tuning using rehash() and reserve().
<br><br>
<br>Load Factor: Monitor and manage the load factor to ensure optimal performance.
<br>Collision Handling: Efficiently handle hash collisions to maintain performance.
<br>Rehashing: Be aware of operations that may trigger rehashing, as it can be costly.
<br><br>std::unordered_multiset is a versatile container in C++ for managing collections of elements where duplicates are allowed, and order is not important. Its hash-based structure offers fast average-time operations, making it suitable for applications requiring efficient access and counting of duplicate items.]]></description><link>dsa-cpp/unordered_multiset.html</link><guid isPermaLink="false">dsa-cpp/Unordered_multiset.md</guid><pubDate>Sat, 27 Jul 2024 14:16:02 GMT</pubDate></item><item><title><![CDATA[Unordered-set]]></title><description><![CDATA[ 
 <br><br>std::unordered_set is a container in the C++ Standard Library that stores unique elements in no particular order. It is implemented using a hash table, which allows for average constant-time complexity for insertions, deletions, and lookups.<br><br>
<br>Unique Elements: Only stores unique elements. Duplicate elements are not allowed.
<br>No Order: The elements are not stored in any specific order.
<br>Hashing: Uses a hash table for storage, which provides fast access to elements.
<br>Constant Time Operations: Average O(1) complexity for insertion, deletion, and search operations. In the worst-case scenario, these operations could degrade to O(n).
<br><br>
#include &lt;unordered_set&gt;

// Declaration
std::unordered_set&lt;int&gt; mySet;

// Insertion
mySet.insert(10);
mySet.insert(20);

// Check existence
if (mySet.find(10) != mySet.end()) {
    // Element found
}

// Deletion
mySet.erase(20);

// Iteration
for (const auto&amp; element : mySet) {
    std::cout &lt;&lt; element &lt;&lt; " ";
}
Copy<br><br>
<br>insert(const value_type&amp; val): Adds an element to the set.
<br>erase(const key_type&amp; key): Removes the element with the specified key.
<br>find(const key_type&amp; key): Searches for the specified key and returns an iterator to the element if found, otherwise returns end().
<br>size(): Returns the number of elements in the set.
<br>empty(): Checks if the set is empty.
<br>clear(): Removes all elements from the set.
<br>begin() / end(): Returns an iterator to the beginning/end of the set.
<br><br>#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; mySet;

    // Insert elements
    mySet.insert(1);
    mySet.insert(2);
    mySet.insert(3);
    mySet.insert(4);

    // Check if an element exists
    if (mySet.find(2) != mySet.end()) {
        std::cout &lt;&lt; "Element 2 found in the set." &lt;&lt; std::endl;
    }

    // Erase an element
    mySet.erase(3);

    // Iterate over the elements
    std::cout &lt;&lt; "Elements in the set: ";
    for (const int&amp; elem : mySet) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Output the size of the set
    std::cout &lt;&lt; "Size of the set: " &lt;&lt; mySet.size() &lt;&lt; std::endl;

    return 0;
}
Copy<br><br>
<br>Fast Lookups: Ideal for scenarios where fast lookup, insertion, and deletion are needed without caring about the order of elements.
<br>Unique Collections: Use when you need to store a collection of unique items.
<br>Hash-Based Storage: Useful when elements can be quickly hashed and where equality comparison is cheap.
<br><br>
<br>Order: std::set is an ordered set, whereas std::unordered_set is unordered.
<br>Underlying Data Structure: std::set uses a binary tree (typically a red-black tree), while std::unordered_set uses a hash table.
<br>Complexity: std::set has O(log n) complexity for insertions, deletions, and searches, while std::unordered_set has average O(1) complexity.
<br><br>
<br>Hash Function: The performance depends heavily on the quality of the hash function used.
<br>Iterators: Iterators are invalidated on rehashing, which may happen after insertions.
<br>Bucket Count: You can control the number of buckets and load factors for performance tuning. Use rehash() and reserve() to manage bucket allocation.
<br><br>
<br>Load Factor: Monitor and manage the load factor to ensure optimal performance.
<br>Collision Handling: Handle hash collisions efficiently for best performance.
<br>Rehashing: Be aware that operations that modify the container may trigger rehashing, which can be costly.
<br><br>std::unordered_set is a powerful container when you need a fast and efficient way to store and access unique elements without regard to their order. It is especially useful in situations where hash-based storage is advantageous and where operations need to be performed in average constant time.]]></description><link>dsa-cpp/unordered-set.html</link><guid isPermaLink="false">dsa-cpp/Unordered-set.md</guid><pubDate>Sat, 27 Jul 2024 14:10:04 GMT</pubDate></item><item><title><![CDATA[Vector]]></title><description><![CDATA[ 
 <br><br>std::vector is a dynamic array provided by the C++ Standard Library. It offers the ability to store elements contiguously and automatically resizes when new elements are added beyond its current capacity.<br><br>
<br>Dynamic Sizing: Automatically resizes to accommodate new elements.
<br>Contiguous Memory: Stores elements in contiguous memory locations, allowing random access with constant time complexity.
<br>Efficient Access: Fast element access using the subscript operator ([]).
<br>Versatile: Can store any data type, including user-defined types.
<br><br>#include &lt;vector&gt;

// Declaration
std::vector&lt;int&gt; myVector;

// Insertion
myVector.push_back(10);
myVector.push_back(20);

// Access elements
int firstElement = myVector[0];

// Size of the vector
size_t size = myVector.size();

// Iteration
for (const auto&amp; element : myVector) {
    std::cout &lt;&lt; element &lt;&lt; " ";
}
Copy<br><br>
<br>push_back(const T&amp; val): Adds an element to the end of the vector.
<br>pop_back(): Removes the last element from the vector.
<br>size(): Returns the number of elements in the vector.
<br>empty(): Checks if the vector is empty.
<br>clear(): Removes all elements from the vector.
<br>begin() / end(): Returns an iterator to the beginning/end of the vector.
<br>insert(iterator pos, const T&amp; val): Inserts an element at the specified position.
<br>erase(iterator pos): Removes the element at the specified position.
<br>resize(size_type count): Resizes the vector to contain count elements.
<br>reserve(size_type new_cap): Increases the capacity of the vector to at least new_cap.
<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; myVector;

    // Insert elements
    myVector.push_back(1);
    myVector.push_back(2);
    myVector.push_back(3);
    myVector.push_back(4);

    // Access elements
    std::cout &lt;&lt; "First element: " &lt;&lt; myVector[0] &lt;&lt; std::endl;

    // Iterate over the elements
    std::cout &lt;&lt; "Elements in the vector: ";
    for (const int&amp; elem : myVector) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Output the size of the vector
    std::cout &lt;&lt; "Size of the vector: " &lt;&lt; myVector.size() &lt;&lt; std::endl;

    // Remove the last element
    myVector.pop_back();

    // Check if the vector is empty
    if (myVector.empty()) {
        std::cout &lt;&lt; "The vector is empty." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "The vector is not empty." &lt;&lt; std::endl;
    }

    // Clear all elements
    myVector.clear();

    return 0;
}

Copy<br><br>
<br>Dynamic Arrays: Use when you need a dynamic array that can change size at runtime.
<br>Random Access: Suitable for scenarios requiring efficient random access to elements.
<br>Storage of Elements: Ideal for storing collections of elements where the size can vary.
<br><br><br>
<br>Size: std::array has a fixed size, while std::vector is dynamic.
<br>Memory Allocation: std::array does not manage memory dynamically, whereas std::vector does.
<br><br>
<br>Memory: std::list stores elements in non-contiguous memory locations, while std::vector stores them contiguously.
<br>Complexity: std::list allows constant time insertions and deletions at both ends, whereas std::vector requires shifting elements for such operations.
<br><br>
<br>Capacity vs Size: The capacity of a vector is the total number of elements it can hold before needing to allocate more memory, whereas size is the number of elements currently in the vector.
<br>Reallocation: When the capacity is exceeded, the vector reallocates memory, doubling its capacity by default. This operation can be costly.
<br>Iterator Invalidations: Inserting or erasing elements can invalidate iterators and references to elements.
<br><br>
<br>Reserve Capacity: Use reserve() to prevent frequent reallocations when the size of the vector is known ahead of time.
<br>Cache Efficiency: Vectors are cache-friendly due to contiguous memory storage, providing faster access to elements.
<br>Resizing Costs: Resizing a vector can be expensive due to potential memory reallocation and element copying.
<br><br>std::vector is a versatile and powerful container in C++ for managing dynamic arrays. Its ability to resize automatically and provide efficient access to elements makes it suitable for various applications requiring dynamic storage and quick access.]]></description><link>dsa-cpp/vector.html</link><guid isPermaLink="false">dsa-cpp/Vector.md</guid><pubDate>Sat, 27 Jul 2024 14:12:27 GMT</pubDate></item><item><title><![CDATA[Chapter Five - Merging]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20240710001858.png" src="git/pasted-image-20240710001858.png"><br>If I follow the parent links of the main branch backward, I can see that the<br>
branch is made up of commits A and B. In other words, the development<br>
history of the main branch consists of commits A and B. On the other hand,<br>
the development history of the chapter_six branch consists of commits A,<br>
B, C, D, and E.<br>
If we can reach one branch through the commit history of another branch, we<br>
say that the development histories of the branches have not diverged. If I<br>
follow the parent links from the chapter_six branch, which points to<br>
commit E, backward, I reach the main branch, which points to commit B.<br>
Therefore, the main branch and the chapter_six branch have not diverged.<br>
If I were to now merge the chapter_six branch into the main branch, a fast-<br>
forward merge would occur. During the fast-forward merge, the main branch<br>
pointer would move forward to point to the commit that the chapter_six branch points to, which is commit E<br><img alt="Pasted image 20240710001945.png" src="git/pasted-image-20240710001945.png"><br>chapter_six is the source branch and main is the<br>
target branch. Figure 5-3 shows that the main branch pointer simply moved<br>
forward from commit B to commit E. This is why these kinds of merges are<br>
called “fast-forward” merges.<br>a three-way merge is a type of<br>
merge that occurs when the development histories of the branches involved in<br>
the merge have diverged. Development histories have diverged when it is not<br>
possible to reach the target branch by following the commit history of the source<br>
branch. In this case when you merge the source branch into the target branch, Git<br>
performs a three-way merge, creating a merge commit to tie the two<br>
development histories together; it then moves the pointer of the target branch to<br>
the merge commit.<br><img alt="Pasted image 20240710190611.png" src="git/pasted-image-20240710190611.png"><br>In Figure 5-5, you can see that the development history of the<br>
chapter_eight branch is made up of commits F, G, H, I, and J. On the other<br>
hand, the commit history of the main branch is made up of commits F, G, K,<br>
and L. There is no way to follow the parent links (represented by gray<br>
arrows) of the chapter_eight branch backward to reach the commit that the<br>
main branch points to, which is commit L. In Git, to describe this situation,<br>
we say that the development histories of the branches have diverged.<br>If I merge the chapter_eight branch into the main branch, it can’t be a fast-<br>
F I G U R E 5 - 4<br>
The commit history of the book repository with the last two commits on the main branch<br>
F I G U R E 5 - 5<br>
An example of a commit history where work has been added to the main branch and the<br>
chapter_eight branch<br>
forward merge because there is no way to just move the branch pointer<br>
forward to combine these two development histories. Instead, a merge<br>
commit (represented by commit M) will be created to tie the two<br>
development histories together, as shown in Figure 5-6. A merge commit is a<br>
commit that has more than one parent. This is an example of a three-way<br>
merge<br><img alt="Pasted image 20240710191000.png" src="git/pasted-image-20240710191000.png"><br>In Figure 5-6, commit M points back to both commit J and commit L. The<br>
reason that this kind of merge is called a three-way merge is because in order<br>
to carry out the merge, Git will take a look at the two commits that the<br>
branches involved in the merge are pointing to—in the case of the book<br>
repository, commit J and commit L—as well as the commit that is the<br>
common ancestor of these two commits, which in this case is commit G.<br>
Hence the name, “three-way” merge<br>Three-way merges are a more complex type of merge where you may experience<br>
merge conflicts. These arise when you merge two branches where different<br>
changes have been made to the same parts of the same file(s), or if in one branch<br>
a file was deleted that was edited in the other branch<br><img alt="Pasted image 20240710191415.png" src="git/pasted-image-20240710191415.png"><br><img alt="Pasted image 20240710191636.png" src="git/pasted-image-20240710191636.png"><br>If Git detects that switching branches will cause you to lose uncommitted<br>
changes in your working directory, then it will stop you from switching branches<br>
and present you with an error message. However, this happens only if the files<br>
that contain uncommitted changes have conflicting changes in the branch you<br>
are switching onto<br>Suppose I want to work on two different approaches for chapter 5 in my book<br>
repository. This means I’ll be working on the chapter_five.txt file. I make<br>
two branches off the main branch, once called chapter_five_approach_a<br>
and one called chapter_five_approach_b.<br>
First I go onto the chapter_five_approach_a branch and work on approach<br>
A. I make a couple commits. In these commits I’m editing the<br>
chapter_five.txt file.<br>
Next, I decide to switch onto the chapter_five_approach_b branch to work<br>
on approach B in my text editor. While on the chapter_five_approach_b<br>
branch, I edit the chapter_five.txt file extensively, but I forget to actually<br>
make any commits on the branch (in other words, to properly save my work).<br>
At some point, I decide I want to switch back to thechapter_five_approach_a branch to check something I had done on that<br>
branch. If Git simply allowed me to switch branches, then the version of the<br>
chapter_five.txt file in my working directory that I was working on in the<br>
chapter_five_approach_b branch would be replaced by the version of the<br>
file in the chapter_five_approach_a branch, and I would lose all my<br>
changes that I had worked on in approach B because I forgot to commit<br>
them.<br>
Luckily, Git won’t let this happen. Instead, it will warn me that I have<br>
uncommitted changes and it will remind me to make a commit so I won’t<br>
lose them.<br>Git will not prevent you from switching branches if you make changes to files without saving<br>
them in the text editor, because those files will be considered unmodified files. So, always<br>
remember to save files in your text editor when you’re done working on them!<br><img alt="Pasted image 20240710193203.png" src="git/pasted-image-20240710193203.png"><br><img alt="Pasted image 20240710193224.png" src="git/pasted-image-20240710193224.png"><br>You have just explicitly observed that switching branches changes the contents<br>
of the working directory<br> I mentioned that the git log command shows a list of commits in reverse chronological order. However, in reality, it shows only a list of commits that are reachable by following the parent links from the commit you are on when you execute the command. To see a list<br>
of commits for all the branches in your local repository, you must use the git log command with the --all option.<br><img alt="Pasted image 20240710193423.png" src="git/pasted-image-20240710193423.png"><br><img alt="Pasted image 20240710193701.png" src="git/pasted-image-20240710193701.png"><br>I mentioned that the git checkout command may be used to<br>
switch branches as well as to carry out other actions. One of the other things you<br>
can do with the git checkout command is check out commits.<br>
At the moment, you are on the main branch, which points to the yellow commit.<br>
But what if you want to look at an older version of your project? For example,<br>
what if you want to see the state of your project at the orange commit?<br>
There is currently no branch pointing to the orange commit, so you can’t switch<br>
onto it by switching onto a branch. Instead, you can choose to check out that<br>
commit by using the git checkout command and passing in the commit hash of<br>
the orange commit<br><img alt="Pasted image 20240710194107.png" src="git/pasted-image-20240710194107.png"><br>When you do this, the git checkout command will carry out three actions that<br>
are similar to the ones described in Chapter 4 and earlier in this chapter:<br>
<br>It changes the HEAD pointer to point to the commit you are switching onto.
<br>It populates the staging area with all the files and directories that are part of<br>
the commit you are switching onto.
<br>It copies the contents of the staging area into the working directory.<br>
The main difference between these steps and the steps mentioned previously is<br>
that in step 1 the HEAD pointer will point directly to a commit instead of pointing<br>
to a branch. This means that you will be in something that Git (scarily) calls<br>
detached HEAD state. This allows you to look at any commit—or, in other<br>
words, any version of your project—in your entire repository.<br>
As these steps indicate, checking out commits changes the contents of the<br>
working directory in the same way that switching branches does.
<br><img alt="commitCheckout.png" src="git/commitcheckout.png"><br><img alt="createBranch.png" src="git/createbranch.png">]]></description><link>git/chapter-five-merging.html</link><guid isPermaLink="false">git/Chapter Five - Merging.md</guid><pubDate>Wed, 10 Jul 2024 14:34:49 GMT</pubDate><enclosure url="git/pasted-image-20240710001858.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;git/pasted-image-20240710001858.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Four]]></title><description><![CDATA[ 
 <br>Why Do We Use Branches?<br>
Before we get into the specifics of branches in Git, I want to explain why they’re<br>
so useful. There are two main reasons to use branches:<br>
• To work on the same project in different ways.<br>
• To help multiple people work on the same project at the same time.<br>One common pattern for working with branches is to have one official primary<br>
line of development—the main or primary branch—and off of that to create<br>
secondary branches, called topic branches or feature branches, that are used to<br>
work on just a specific part of the project. These topic branches are short-lived;<br>
they are ultimately combined or incorporated back into the primary branch and<br>
then deleted. The two processes you can use to integrate one branch into another<br>
are called merging and rebasing.<br>In the git log output, next to the commit hash inside the parentheses you<br>
see HEAD -&gt; main.<br>
The branch or branches that appear inside the parentheses next to a particular<br>
commit hash in the git log output are the branches that point to that commit.<br>Within the rainbow project directory in your filesystem window, go to .git &gt; refs &gt;<br>
heads &gt; main<br>Inside the main file you will see the commit hash for the red<br>
commit in your rainbow repository<br>refs stand for references<br>The heads directory stores a file for each local<br>
branch in your local repository. At the moment you only have one local branch,<br>
the main branch, so there is only one file in this directory. You can think of that<br>
file as storing the “head” of that branch; in other words, the latest commit on that<br>
branch.<br>Git<br>
knows about the rainbowcolors.txt file because it has been included in a<br>
commit, and therefore it is a tracked file<br>Tracked files in the working directory can be in one of two states. Unmodified<br>
files are files in the working directory that have not been edited since the last<br>
commit. Once a file in the working directory has been edited (and saved in the<br>
text editor), it becomes a modified file. Since your last commit, you have not<br>
edited the rainbowcolors.txt file; therefore, it is an unmodified file.<br><img alt="Pasted image 20240612203517.png" src="git/pasted-image-20240612203517.png"><br>In the Visualize It diagrams, gray arrows are used to represent parent links and black<br>
arrows are used to represent branch pointers.<br>second commit "orange", main points to orange, which points to red<br>To check which commit is the parent of a given commit, you can use the git<br>
cat-file command with the -p option and pass in a commit hash: git cat-<br>
file -p &lt;commit_hash&gt;.<br><img alt="Pasted image 20240612203810.png" src="git/pasted-image-20240612203810.png"><br>In the git cat-file -p output, you can see that next to parent it<br>
references the commit hash of the red commit in this book. In your output,<br>
it will reference the commit hash of your red commit<br><img alt="Pasted image 20240612203908.png" src="git/pasted-image-20240612203908.png"><br><img alt="Pasted image 20240612204054.png" src="git/pasted-image-20240612204054.png"><br>A new branch willinitially point to the commit that you were on when you made the branch. In this case, you can say that you “made the feature branch off of the main branch.”<br>
That is why the feature branch and main branch both now point to the same<br>
commit.<br>WHAT IS HEAD?<br>
At any given point in time, you are looking at a particular version of your<br>
project. Therefore, you are on a particular branch which is pointing to a commit.<br>
HEAD is simply a pointer that tells you which branch you are on.<br><img alt="Pasted image 20240612204321.png" src="git/pasted-image-20240612204321.png"><br><img alt="Pasted image 20240612204333.png" src="git/pasted-image-20240612204333.png"><br>HEAD (in capital letters) should not be confused with the heads directory that can be found in .git &gt; refs &gt; heads. The heads directory stores a file for every local branch in your local<br>
repository, while HEAD indicates which branch you are on by referencing one of the files<br>
inside the heads directory. You can distinguish them because HEAD is always in capital letters.<br>To work on another branch (or line of development) in a Git project, you have to<br>
switch onto that branch. Another way of saying this in Git terminology is that<br>
you have to “check out” another branch.<br>
You currently have two branches, main and feature. But as you’ve just seen,<br>
just because you make a branch in Git does not mean that you automatically<br>
switch onto that branch. You must explicitly instruct Git that you want to switch<br>
onto a branch. You can do this using either the git switch command or the git<br>
checkout command, passing in the name of the branch that you want to switch<br>
onto.<br><img alt="Pasted image 20240612204523.png" src="git/pasted-image-20240612204523.png"><br>The git switch (or git checkout) command does three things when used to<br>
switch branches:<br>
<br>It changes the HEAD pointer to point to the branch you are switching onto.
<br>It populates the staging area with a snapshot of the commit you are<br>
switching onto.
<br>It copies the contents of the staging area into the working directory.
<br>Upon doing,<br>
git switch feature<br>
<img alt="Pasted image 20240612204945.png" src="git/pasted-image-20240612204945.png"><br>HEAD now points towards the feature branch : can check through .git/HEAD<br><img alt="Pasted image 20240612205131.png" src="git/pasted-image-20240612205131.png"><br>
Commiting Yellow on branch feature<br><img alt="Pasted image 20240612205217.png" src="git/pasted-image-20240612205217.png">]]></description><link>git/chapter-four.html</link><guid isPermaLink="false">git/Chapter Four.md</guid><pubDate>Wed, 12 Jun 2024 15:22:19 GMT</pubDate><enclosure url="git/pasted-image-20240612203517.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;git/pasted-image-20240612203517.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter one]]></title><description><![CDATA[ 
 <br>What Is Git?<br>
Git is a technology that can be used to track changes to a project and to help<br>
multiple people to collaborate on a project. At a basic level, a project version<br>
controlled by Git consists of a folder with files in it, and Git tracks the changes<br>
that are made to the files in the project. This allows you to save different<br>
versions of the work you’re doing, which is why we call Git a version control<br>
system.<br>git commit -m ""<br>
-m -&gt; option<br>
 -&gt; argument<br>
options are denoted by - or --<br>pwd - print working directory<br>Commands<br>
git config --global  --list : list the variables in the global git configuration file and their values<br>
it will show information of the global git configuration file -&gt; usually .gitconfig file<br><img alt="image1.png" src="git/image1.png"><br>Variables we are interested in are: user.email and user.name. Every time someone saves a version of their project(i.e commits), Git will note down the name and email address of the individual and associate it with that saved version.The user.name and user.email variables<br>
are used to set the name and email address that will be saved for the commits<br>
you make. This means that you can see who worked on what in a Git project.<br>To set these variables in your global Git configuration file, you pass them as<br>
arguments to the git config command, entering your desired values inside<br>
quotation marks.<br><img alt="image2.png" src="git/image2.png"><br>Text editor - Program that allows a user to edit plain text.<br>
Some advanced text editors like VS Code ~ IDEs (Integrated Development Environment) come with integrated terminal, in which you can execute the commands you would normally use in your command line window.]]></description><link>git/chapter-one.html</link><guid isPermaLink="false">git/Chapter one.md</guid><pubDate>Sun, 09 Jun 2024 12:28:13 GMT</pubDate><enclosure url="git/image1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;git/image1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Seven - Creating and Pushing to a Remote Repository]]></title><description><![CDATA[ 
 <br>STARTING FROM A LOCAL REPOSITORY<br>
To start to work on a Git project from a local repository, you must first create a<br>
local repository on a computer using the git init command and make at least<br>
one commit. Next, you must create a remote repository on a hosting service.<br>
Finally, you may upload data from the local repository to the remote repository.<br>
In Git, we use the term push or pushing to refer to the process of uploading data<br>
from a local repository to a remote repository, and the command we use to do<br>
this is git push.<br><img alt="Pasted image 20240712151008.png" src="git/pasted-image-20240712151008.png"><br>Local repositories and remote repositories act separately. When it comes to<br>
working with them, it’s important to understand that no interaction between them<br>
happens automatically. In other words, no updates from the local repository to<br>
the remote repository will happen automatically, and conversely, no updates<br>
from the remote repository to the local repository will happen automatically.<br>
There is no live connection between the two. Any changes in either will be the<br>
result of you explicitly executing commands. In this and the following chapters,<br>
you will learn what these commands are<br>Why Do We Use Remote Repositories?<br>
There are three main reasons why remote repositories are useful and important<br>
when working on a Git project. They allow you to:<br>
• Easily back up your project somewhere other than your computer.<br>
• Access a Git project from multiple computers.<br>
• Collaborate with others on Git projects.<br>If a local repository was initialized locally, to set up a connection to a remote<br>
repository you must explicitly associate the remote repository URL to the remote<br>
repository shortname. To do this you use the git remote add command, passing<br>
in the shortname followed by the remote repository URL.<br><img alt="Pasted image 20240712171215.png" src="git/pasted-image-20240712171215.png"><br><img alt="Pasted image 20240712171307.png" src="git/pasted-image-20240712171307.png"><br>In the official Git documentation, a connection to a remote repository stored in a local<br>
repository is simply referred to as a remote<br>To see the list of connections to remote repositories stored in a local repository<br>
by shortname, you may use the git remote command. If you pass in the -v<br>
option (which stands for “verbose”) to the git remote command, then it lists the<br>
connections to remote repositories stored in a local repository by shortname<br>
along with their URLs.<br><img alt="Pasted image 20240712171545.png" src="git/pasted-image-20240712171545.png"><br><img alt="Pasted image 20240712171658.png" src="git/pasted-image-20240712171658.png"><br><img alt="Pasted image 20240712184557.png" src="git/pasted-image-20240712184557.png"><br>• The rainbow repository has a shortname associated with the remote<br>
repository URL, called origin.<br>
• The rainbow-remote repository still does not have any data in it.<br>You can see that the arrow that represents the shortname<br>
stored in the rainbow repository that relates to the rainbow-remote repository is<br>
going in only one direction. This is because the connection between a local and a<br>
remote repository goes from the local repository to the remote repository but not<br>
the other way around. In a local repository, you can find a list of all the remote<br>
repositories it has stored a connection to; however, in a remote repository you<br>
cannot find a list of local repositories that store a connection to that remote<br>
repository.<br>Notice as well that just because you added a connection to the remote repository<br>
in your local repository does not mean that any data from the local repository<br>
was uploaded to the remote repository. To upload data to a remote repository,<br>
you must push a branch to the remote repository. This process will upload all the<br>
commits that are part of that branch<br>In Chapter 4 you learned about branches, which as you saw are movable pointers<br>
to commits. Up until now, you have worked only with local branches. When you<br>
push a local branch to a remote repository, you will create a remote branch. A<br>
remote branch is a branch in a remote repository.<br>Remote branches do not automatically update when you make more commits on<br>
local branches. You have to explicitly push commits from a local branch to a<br>
remote branch. Every remote branch (that a local repository knows about) also<br>
has a remote-tracking branch. This is a reference in a local repository to the<br>
commit a remote branch pointed at the last time any network communication<br>
happened with the remote repository. You can think of it as being like a<br>
bookmark<br>You can set up a tracking relationship between a local branch and a remote<br>
branch by defining which remote branch a local branch should track. This is<br>
referred to as the upstream branch. There are some cases where Git will set the<br>
upstream branch automatically, but in other cases you have to set it explicitly.<br>When you push work from a local branch to a remote branch, Git needs to know<br>
which remote branch you want to push to. If the local branch has an upstream<br>
branch defined for it, you can use git push with no arguments, and Git will<br>
automatically push the work to that branch. However, if no upstream branch is<br>
defined for the local branch you’re working on, you’ll need to specify which<br>
remote branch to push to when you enter the git push command<br>To push a local branch to your remote repository, you will use the git push<br>
command and pass in the shortname for the remote repository and the name of<br>
the branch that you want to push. For the rainbow repository, the shortname you<br>
will use is origin and the branch you will push is main.<br><img alt="Pasted image 20240712185501.png" src="git/pasted-image-20240712185501.png"><br>After you execute the git push command, two things will happen:<br>
<br>A remote branch will be created in your remote repository.
<br>A remote-tracking branch will be created in your local repository
<br>To push data to a remote repository, you must be connected to the internet and have either<br>
SSH access or HTTPS access to your hosting service of choice.<br><img alt="Pasted image 20240712185757.png" src="git/pasted-image-20240712185757.png"><br><img alt="Pasted image 20240712190519.png" src="git/pasted-image-20240712190519.png"><br><img alt="Pasted image 20240712190538.png" src="git/pasted-image-20240712190538.png"><br>4]]></description><link>git/chapter-seven-creating-and-pushing-to-a-remote-repository.html</link><guid isPermaLink="false">git/Chapter Seven - Creating and Pushing to a Remote Repository.md</guid><pubDate>Fri, 12 Jul 2024 19:07:29 GMT</pubDate><enclosure url="git/pasted-image-20240712151008.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;git/pasted-image-20240712151008.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Six - Hosting Services and Authentication]]></title><description><![CDATA[ 
 <br> two types of repositories: local repositories and remote<br>
repositories. Local repositories are found on a computer, while remote<br>
repositories are hosted on a hosting service in the cloud.<br>To transfer data between a local repository and a remote repository on a hosting<br>
service, you must connect and authenticate using either SSH or HTTPS<br>The HTTPS protocol uses a username and some sort of password (or<br>
authentication credential) to allow you to securely connect to remote<br>
repositories. In the past, all the hosting services allowed you to use the password<br>
you use to log in to your account on the hosting service (which we will refer to<br>
as the account password) for HTTPS authentication as well. However, GitHub<br>
and Bitbucket no longer allow this; they require you to create another<br>
authentication credential.<br>
In GitHub, the authentication credential is called a personal access token. In<br>
Bitbucket, it’s called an app password. With GitLab, you can still simply use<br>
your account password to authenticate. See Table 6-1 for an overview of the<br>
three most common hosting services and the access credentials necessary to<br>
authenticate over HTTPS<br>Setting up HTTPS: <a rel="noopener" class="external-link" href="https://github.com/gitlearningjourney/learning-git" target="_blank">https://github.com/gitlearningjourney/learning-git</a><br>USING SSH<br>
The SSH protocol uses a public and private SSH key pair to allow you to<br>
securely connect to remote repositories. The three main steps to setting up SSH<br>
access are:<br>
<br>Create an SSH key pair on your computer.
<br>Add the private SSH key to the SSH agent.
<br>Add the public SSH key to the hosting service account.
<br>Setting up SSH: <a rel="noopener" class="external-link" href="https://github.com/gitlearningjourney/learning-git" target="_blank">https://github.com/gitlearningjourney/learning-git</a>]]></description><link>git/chapter-six-hosting-services-and-authentication.html</link><guid isPermaLink="false">git/Chapter Six - Hosting Services and Authentication.md</guid><pubDate>Fri, 12 Jul 2024 09:07:49 GMT</pubDate></item><item><title><![CDATA[Chapter Three]]></title><description><![CDATA[ 
 <br>COMMIT EARLY, COMMIT OFTEN<br>git status - Tells you the state of the working directory and the staging area, this is useful because in a project with many files it is easy to lose track of what state the files in your working directory are in and which files you've added to the staging area.<br>In a project with many files, it can be hard to remember which files are untracked, which files are tracked, and which files you’ve edited. <br>Example Book Project 3-1<br>
The Book project I’m working on consists of 10 files, one for each chapter in the book. After working on the book for a while in between commits, I may forget which chapter files I have edited. I know I worked on chapters 2 and 3, but did I make any changes in chapter 4? If so, I don’t want to lose them.<br>
In this case, the git status command can help me by telling me which<br>
chapter files I’ve edited, which ones I’ve added to the staging area, and which ones I have yet to add.<br><img alt="Pasted image 20240610222102.png" src="git/pasted-image-20240610222102.png"><br><img alt="Pasted image 20240610222148.png" src="git/pasted-image-20240610222148.png"><br>
rainbow project<br>** No commits yet- The commit history doesn't have any commits at this point of time.<br><img alt="Pasted image 20240610222416.png" src="git/pasted-image-20240610222416.png"><br>The staging area allows you to choose which updated files (or changes) will be included in your next commit. The general rule is to group related changes together. This allows you to keep your commits more organized.<br>This first step of the committing process allows you to be very specific about what you include in a commit. This means that you can edit many files in your project, but you don’t have to save them all in one commit.<br>In the Rainbow project, the rainbowcolors.txt file is the first file you will add<br>
to the staging area. This means that when you add this file, the index file (which<br>
represents the staging area in the .git directory) will be created. As you learned<br>
in Chapter 2, this file does not exist until you add a file to the staging area.The<br>
index file is a binary file, which means the actual contents look like gibberish to<br>
a human and are not easily understandable. For our purposes, we only need to<br>
understand that it represents the staging area.<br><img alt="Pasted image 20240610230007.png" src="git/pasted-image-20240610230007.png"><br><img alt="Pasted image 20240610230047.png" src="git/pasted-image-20240610230047.png"><br>The rainbowcolors.txt file is now both in the working directory and in the<br>
staging area. This is because the git add command does not move a file from<br>
the working directory to the staging area. It copies the file from the working<br>
directory into the staging area.<br><img alt="Pasted image 20240610230131.png" src="git/pasted-image-20240610230131.png"><br>Upon running git add rainbowcolours.txt git commit -m "Red"<br>
<img alt="Pasted image 20240610230458.png" src="git/pasted-image-20240610230458.png"><br>The output of the git commit command shows the first seven characters of<br>
the commit hash for the red commit, which is c26d0bc in this book. The<br>
first seven characters of your commit hash will be different.<br><img alt="Pasted image 20240610230557.png" src="git/pasted-image-20240610230557.png"><br>Viewing a List of Commits<br>
To see a list of commits in the commit history, you use the git log command.<br>
The git log command lists the commits in a local repository in reverse<br>
chronological order. It displays four pieces of information about each commit:<br>
<br>Commit hash
<br>Author name and email address
<br>Date and time commit was made
<br>Commit message
<br><img alt="Pasted image 20240610230812.png" src="git/pasted-image-20240610230812.png">]]></description><link>git/chapter-three.html</link><guid isPermaLink="false">git/Chapter Three.md</guid><pubDate>Mon, 10 Jun 2024 17:38:14 GMT</pubDate><enclosure url="git/pasted-image-20240610222102.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;git/pasted-image-20240610222102.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Two]]></title><description><![CDATA[ 
 <br>Repository/ repo is how we refer to a project version controlled by GIt.<br>
Two types of repos:<br>
-Local repo: Stored on a computer<br>
-Remote repo: Hosted on a hosting service<br>Hosting service: Companies that provide hosting for projects using Git. Eg: GitHub, GitLab, BitBucket<br>A local repository is represented by a hidden directory called .git that exists<br>
within a project directory. It contains all the data on the changes that have been<br>
made to the files in a project.<br>
To turn a project directory into a local repository you have to initialize, or create,<br>
the repository. When you initialize a repository, the .git directory is<br>
automatically created inside the project directory. Because the .git directory is a<br>
hidden directory, you won’t be able to see it unless you explicitly make hidden<br>
files and directories visible.<br>Normally we initialize a Git repo using git init command, with no additional options; however, in the rainbow project(/dev/oreilly/learning-git/rainbow), we wil use  git init -b where -b stands for --initiali-branch and pass in the name main(argument).<br>Hence, git init -b main<br>By default Git will create a branch called master when you initialize a new<br>
local repository. From Git version 2.28 onwards, the name of the initial branch is<br>
configurable. I have chosen to use the name main instead of master in this book,<br>
because “master” is not considered inclusive terminology.<br><img alt="image3.png" src="git/image3.png"><br>Running the command: git init -b main* in the rainbow repo*<br><img alt="image4.png" src="git/image4.png"><br>
The contents of .git repo right after running git init command<br>Four important areas to be aware of when working with Git:<br>
- Working directory<br>
- Staging area<br>
-  Commit History<br>
-  Local repository<br>Introduction to Working Directory:
	The working directory contains the files and directories in the project directorythat represent one version of a project. It is sort of like a workbench. It is where you add, edit, and delete files and directories.

	![[workingDirectory.png]]
	

Introduction to the Staging Area:
	The staging area is similar to a rough draft space. It is where you can add and remove files, when you are preparing what you want to include in the next saved version of your project (your next commit). The staging area is represented by a file in the .git directory called index.

	![[stagingArea.png]]
	

What is a Commit ?
	A Commit in Git is basically one version of a project.
	Every commit has a commit hash (sometimes called a commit ID). This is a unique 40-character hash composed of letters and numbers that acts like a name for the commit, providing a way to refer to it. An example of a commit hash is 51dc6ecb327578cca503abba4a56e8c18f3835e1. In reality, you only need the first seven characters of a commit hash to refer to a commit. So, for the example hash just given, you can just use 51dc6ec to refer to the commit.

Introducing the Commit History
	The commit history is where you can think of your commits existing. It is represented by the objects directory inside the .git directory.

	![[commitHistory.png]]
Copy<br><img alt="rainbowColors.png" src="git/rainbowcolors.png"><br>Since the rainbowcolors.txt file is not yet in your repository, it is an untracked<br>
file. An untracked file is a file in the working directory that Git is not version<br>
controlling. It has never been added to the staging area and it has never been<br>
included in a commit; therefore, it is not part of the repository.<br>
Once you add a file to the staging area and include it in a commit, the file<br>
becomes a tracked file. This is a file that is version controlled (in other words, a<br>
file that Git tracks).<br>
Every new file in a project version controlled by Git needs to be explicitly added<br>
to the staging area and then included in a commit in order to become a tracked<br>
file.]]></description><link>git/chapter-two.html</link><guid isPermaLink="false">git/Chapter Two.md</guid><pubDate>Sun, 09 Jun 2024 12:45:02 GMT</pubDate><enclosure url="git/image3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;git/image3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Git Index]]></title><description><![CDATA[ 
 <br><a data-href="Chapter one" href="git/chapter-one.html" class="internal-link" target="_self" rel="noopener">Chapter one</a><br>
<a data-href="Chapter Two" href="git/chapter-two.html" class="internal-link" target="_self" rel="noopener">Chapter Two</a><br>
<a data-href="Chapter Three" href="git/chapter-three.html" class="internal-link" target="_self" rel="noopener">Chapter Three</a><br>
<a data-href="Chapter Four" href="git/chapter-four.html" class="internal-link" target="_self" rel="noopener">Chapter Four</a><br>
<a data-href="Chapter Five - Merging" href="git/chapter-five-merging.html" class="internal-link" target="_self" rel="noopener">Chapter Five - Merging</a><br>
<a data-href="Chapter Six - Hosting Services and Authentication" href="git/chapter-six-hosting-services-and-authentication.html" class="internal-link" target="_self" rel="noopener">Chapter Six - Hosting Services and Authentication</a><br>
<a data-href="Chapter Seven - Creating and Pushing to a Remote Repository" href="git/chapter-seven-creating-and-pushing-to-a-remote-repository.html" class="internal-link" target="_self" rel="noopener">Chapter Seven - Creating and Pushing to a Remote Repository</a>]]></description><link>git/git-index.html</link><guid isPermaLink="false">git/Git Index.md</guid><pubDate>Fri, 26 Jul 2024 13:36:51 GMT</pubDate></item><item><title><![CDATA[Lists]]></title><description><![CDATA[ 
 <br>len()<br>
type()]]></description><link>python/lists.html</link><guid isPermaLink="false">python/Lists.md</guid><pubDate>Sat, 03 Aug 2024 17:46:50 GMT</pubDate></item><item><title><![CDATA[Python for dsa]]></title><description><![CDATA[ 
 <br>numList = list(dict.items())<br>numList.sort(key = lambda x: x[1], reverse = True)]]></description><link>python/python-for-dsa.html</link><guid isPermaLink="false">python/Python for dsa.md</guid><pubDate>Sat, 03 Aug 2024 18:08:36 GMT</pubDate></item><item><title><![CDATA[Hello There]]></title><description><![CDATA[ 
 <br>These are my haphazard unorganized notes<br><a data-href="Git Index" href="git/git-index.html" class="internal-link" target="_self" rel="noopener">Git Index</a><br>
<a data-href="Python for dsa" href="python/python-for-dsa.html" class="internal-link" target="_self" rel="noopener">Python for dsa</a><br>
<a data-href="STL - Standard Template Library" href="dsa-cpp/stl-standard-template-library.html" class="internal-link" target="_self" rel="noopener">STL - Standard Template Library</a>]]></description><link>hello-there.html</link><guid isPermaLink="false">Hello There.md</guid><pubDate>Mon, 12 Aug 2024 19:40:27 GMT</pubDate></item></channel></rss>