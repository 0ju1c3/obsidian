<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>obsidian</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 28 Sep 2024 09:30:47 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 28 Sep 2024 09:30:43 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Chapter Five - Merging]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20240710001858.png" src="git/pasted-image-20240710001858.png"><br>If I follow the parent links of the main branch backward, I can see that the<br>
branch is made up of commits A and B. In other words, the development<br>
history of the main branch consists of commits A and B. On the other hand,<br>
the development history of the chapter_six branch consists of commits A,<br>
B, C, D, and E.<br>
If we can reach one branch through the commit history of another branch, we<br>
say that the development histories of the branches have not diverged. If I<br>
follow the parent links from the chapter_six branch, which points to<br>
commit E, backward, I reach the main branch, which points to commit B.<br>
Therefore, the main branch and the chapter_six branch have not diverged.<br>
If I were to now merge the chapter_six branch into the main branch, a fast-<br>
forward merge would occur. During the fast-forward merge, the main branch<br>
pointer would move forward to point to the commit that the chapter_six branch points to, which is commit E<br><img alt="Pasted image 20240710001945.png" src="git/pasted-image-20240710001945.png"><br>chapter_six is the source branch and main is the<br>
target branch. Figure 5-3 shows that the main branch pointer simply moved<br>
forward from commit B to commit E. This is why these kinds of merges are<br>
called “fast-forward” merges.<br>a three-way merge is a type of<br>
merge that occurs when the development histories of the branches involved in<br>
the merge have diverged. Development histories have diverged when it is not<br>
possible to reach the target branch by following the commit history of the source<br>
branch. In this case when you merge the source branch into the target branch, Git<br>
performs a three-way merge, creating a merge commit to tie the two<br>
development histories together; it then moves the pointer of the target branch to<br>
the merge commit.<br><img alt="Pasted image 20240710190611.png" src="git/pasted-image-20240710190611.png"><br>In Figure 5-5, you can see that the development history of the<br>
chapter_eight branch is made up of commits F, G, H, I, and J. On the other<br>
hand, the commit history of the main branch is made up of commits F, G, K,<br>
and L. There is no way to follow the parent links (represented by gray<br>
arrows) of the chapter_eight branch backward to reach the commit that the<br>
main branch points to, which is commit L. In Git, to describe this situation,<br>
we say that the development histories of the branches have diverged.<br>If I merge the chapter_eight branch into the main branch, it can’t be a fast-<br>
F I G U R E 5 - 4<br>
The commit history of the book repository with the last two commits on the main branch<br>
F I G U R E 5 - 5<br>
An example of a commit history where work has been added to the main branch and the<br>
chapter_eight branch<br>
forward merge because there is no way to just move the branch pointer<br>
forward to combine these two development histories. Instead, a merge<br>
commit (represented by commit M) will be created to tie the two<br>
development histories together, as shown in Figure 5-6. A merge commit is a<br>
commit that has more than one parent. This is an example of a three-way<br>
merge<br><img alt="Pasted image 20240710191000.png" src="git/pasted-image-20240710191000.png"><br>In Figure 5-6, commit M points back to both commit J and commit L. The<br>
reason that this kind of merge is called a three-way merge is because in order<br>
to carry out the merge, Git will take a look at the two commits that the<br>
branches involved in the merge are pointing to—in the case of the book<br>
repository, commit J and commit L—as well as the commit that is the<br>
common ancestor of these two commits, which in this case is commit G.<br>
Hence the name, “three-way” merge<br>Three-way merges are a more complex type of merge where you may experience<br>
merge conflicts. These arise when you merge two branches where different<br>
changes have been made to the same parts of the same file(s), or if in one branch<br>
a file was deleted that was edited in the other branch<br><img alt="Pasted image 20240710191415.png" src="git/pasted-image-20240710191415.png"><br><img alt="Pasted image 20240710191636.png" src="git/pasted-image-20240710191636.png"><br>If Git detects that switching branches will cause you to lose uncommitted<br>
changes in your working directory, then it will stop you from switching branches<br>
and present you with an error message. However, this happens only if the files<br>
that contain uncommitted changes have conflicting changes in the branch you<br>
are switching onto<br>Suppose I want to work on two different approaches for chapter 5 in my book<br>
repository. This means I’ll be working on the chapter_five.txt file. I make<br>
two branches off the main branch, once called chapter_five_approach_a<br>
and one called chapter_five_approach_b.<br>
First I go onto the chapter_five_approach_a branch and work on approach<br>
A. I make a couple commits. In these commits I’m editing the<br>
chapter_five.txt file.<br>
Next, I decide to switch onto the chapter_five_approach_b branch to work<br>
on approach B in my text editor. While on the chapter_five_approach_b<br>
branch, I edit the chapter_five.txt file extensively, but I forget to actually<br>
make any commits on the branch (in other words, to properly save my work).<br>
At some point, I decide I want to switch back to thechapter_five_approach_a branch to check something I had done on that<br>
branch. If Git simply allowed me to switch branches, then the version of the<br>
chapter_five.txt file in my working directory that I was working on in the<br>
chapter_five_approach_b branch would be replaced by the version of the<br>
file in the chapter_five_approach_a branch, and I would lose all my<br>
changes that I had worked on in approach B because I forgot to commit<br>
them.<br>
Luckily, Git won’t let this happen. Instead, it will warn me that I have<br>
uncommitted changes and it will remind me to make a commit so I won’t<br>
lose them.<br>Git will not prevent you from switching branches if you make changes to files without saving<br>
them in the text editor, because those files will be considered unmodified files. So, always<br>
remember to save files in your text editor when you’re done working on them!<br><img alt="Pasted image 20240710193203.png" src="git/pasted-image-20240710193203.png"><br><img alt="Pasted image 20240710193224.png" src="git/pasted-image-20240710193224.png"><br>You have just explicitly observed that switching branches changes the contents<br>
of the working directory<br> I mentioned that the git log command shows a list of commits in reverse chronological order. However, in reality, it shows only a list of commits that are reachable by following the parent links from the commit you are on when you execute the command. To see a list<br>
of commits for all the branches in your local repository, you must use the git log command with the --all option.<br><img alt="Pasted image 20240710193423.png" src="git/pasted-image-20240710193423.png"><br><img alt="Pasted image 20240710193701.png" src="git/pasted-image-20240710193701.png"><br>I mentioned that the git checkout command may be used to<br>
switch branches as well as to carry out other actions. One of the other things you<br>
can do with the git checkout command is check out commits.<br>
At the moment, you are on the main branch, which points to the yellow commit.<br>
But what if you want to look at an older version of your project? For example,<br>
what if you want to see the state of your project at the orange commit?<br>
There is currently no branch pointing to the orange commit, so you can’t switch<br>
onto it by switching onto a branch. Instead, you can choose to check out that<br>
commit by using the git checkout command and passing in the commit hash of<br>
the orange commit<br><img alt="Pasted image 20240710194107.png" src="git/pasted-image-20240710194107.png"><br>When you do this, the git checkout command will carry out three actions that<br>
are similar to the ones described in Chapter 4 and earlier in this chapter:<br>
<br>It changes the HEAD pointer to point to the commit you are switching onto.
<br>It populates the staging area with all the files and directories that are part of<br>
the commit you are switching onto.
<br>It copies the contents of the staging area into the working directory.<br>
The main difference between these steps and the steps mentioned previously is<br>
that in step 1 the HEAD pointer will point directly to a commit instead of pointing<br>
to a branch. This means that you will be in something that Git (scarily) calls<br>
detached HEAD state. This allows you to look at any commit—or, in other<br>
words, any version of your project—in your entire repository.<br>
As these steps indicate, checking out commits changes the contents of the<br>
working directory in the same way that switching branches does.
<br><img alt="commitCheckout.png" src="git/commitcheckout.png"><br><img alt="createBranch.png" src="git/createbranch.png">]]></description><link>git/chapter-five-merging.html</link><guid isPermaLink="false">git/Chapter Five - Merging.md</guid><pubDate>Wed, 10 Jul 2024 14:34:49 GMT</pubDate><enclosure url="git/pasted-image-20240710001858.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="git/pasted-image-20240710001858.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Four]]></title><description><![CDATA[ 
 <br>Why Do We Use Branches?<br>
Before we get into the specifics of branches in Git, I want to explain why they’re<br>
so useful. There are two main reasons to use branches:<br>
• To work on the same project in different ways.<br>
• To help multiple people work on the same project at the same time.<br>One common pattern for working with branches is to have one official primary<br>
line of development—the main or primary branch—and off of that to create<br>
secondary branches, called topic branches or feature branches, that are used to<br>
work on just a specific part of the project. These topic branches are short-lived;<br>
they are ultimately combined or incorporated back into the primary branch and<br>
then deleted. The two processes you can use to integrate one branch into another<br>
are called merging and rebasing.<br>In the git log output, next to the commit hash inside the parentheses you<br>
see HEAD -&gt; main.<br>
The branch or branches that appear inside the parentheses next to a particular<br>
commit hash in the git log output are the branches that point to that commit.<br>Within the rainbow project directory in your filesystem window, go to .git &gt; refs &gt;<br>
heads &gt; main<br>Inside the main file you will see the commit hash for the red<br>
commit in your rainbow repository<br>refs stand for references<br>The heads directory stores a file for each local<br>
branch in your local repository. At the moment you only have one local branch,<br>
the main branch, so there is only one file in this directory. You can think of that<br>
file as storing the “head” of that branch; in other words, the latest commit on that<br>
branch.<br>Git<br>
knows about the rainbowcolors.txt file because it has been included in a<br>
commit, and therefore it is a tracked file<br>Tracked files in the working directory can be in one of two states. Unmodified<br>
files are files in the working directory that have not been edited since the last<br>
commit. Once a file in the working directory has been edited (and saved in the<br>
text editor), it becomes a modified file. Since your last commit, you have not<br>
edited the rainbowcolors.txt file; therefore, it is an unmodified file.<br><img alt="Pasted image 20240612203517.png" src="git/pasted-image-20240612203517.png"><br>In the Visualize It diagrams, gray arrows are used to represent parent links and black<br>
arrows are used to represent branch pointers.<br>second commit "orange", main points to orange, which points to red<br>To check which commit is the parent of a given commit, you can use the git<br>
cat-file command with the -p option and pass in a commit hash: git cat-<br>
file -p &lt;commit_hash&gt;.<br><img alt="Pasted image 20240612203810.png" src="git/pasted-image-20240612203810.png"><br>In the git cat-file -p output, you can see that next to parent it<br>
references the commit hash of the red commit in this book. In your output,<br>
it will reference the commit hash of your red commit<br><img alt="Pasted image 20240612203908.png" src="git/pasted-image-20240612203908.png"><br><img alt="Pasted image 20240612204054.png" src="git/pasted-image-20240612204054.png"><br>A new branch willinitially point to the commit that you were on when you made the branch. In this case, you can say that you “made the feature branch off of the main branch.”<br>
That is why the feature branch and main branch both now point to the same<br>
commit.<br>WHAT IS HEAD?<br>
At any given point in time, you are looking at a particular version of your<br>
project. Therefore, you are on a particular branch which is pointing to a commit.<br>
HEAD is simply a pointer that tells you which branch you are on.<br><img alt="Pasted image 20240612204321.png" src="git/pasted-image-20240612204321.png"><br><img alt="Pasted image 20240612204333.png" src="git/pasted-image-20240612204333.png"><br>HEAD (in capital letters) should not be confused with the heads directory that can be found in .git &gt; refs &gt; heads. The heads directory stores a file for every local branch in your local<br>
repository, while HEAD indicates which branch you are on by referencing one of the files<br>
inside the heads directory. You can distinguish them because HEAD is always in capital letters.<br>To work on another branch (or line of development) in a Git project, you have to<br>
switch onto that branch. Another way of saying this in Git terminology is that<br>
you have to “check out” another branch.<br>
You currently have two branches, main and feature. But as you’ve just seen,<br>
just because you make a branch in Git does not mean that you automatically<br>
switch onto that branch. You must explicitly instruct Git that you want to switch<br>
onto a branch. You can do this using either the git switch command or the git<br>
checkout command, passing in the name of the branch that you want to switch<br>
onto.<br><img alt="Pasted image 20240612204523.png" src="git/pasted-image-20240612204523.png"><br>The git switch (or git checkout) command does three things when used to<br>
switch branches:<br>
<br>It changes the HEAD pointer to point to the branch you are switching onto.
<br>It populates the staging area with a snapshot of the commit you are<br>
switching onto.
<br>It copies the contents of the staging area into the working directory.
<br>Upon doing,<br>
git switch feature<br>
<img alt="Pasted image 20240612204945.png" src="git/pasted-image-20240612204945.png"><br>HEAD now points towards the feature branch : can check through .git/HEAD<br><img alt="Pasted image 20240612205131.png" src="git/pasted-image-20240612205131.png"><br>
Commiting Yellow on branch feature<br><img alt="Pasted image 20240612205217.png" src="git/pasted-image-20240612205217.png">]]></description><link>git/chapter-four.html</link><guid isPermaLink="false">git/Chapter Four.md</guid><pubDate>Wed, 12 Jun 2024 15:22:19 GMT</pubDate><enclosure url="git/pasted-image-20240612203517.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="git/pasted-image-20240612203517.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter one]]></title><description><![CDATA[ 
 <br>What Is Git?<br>
Git is a technology that can be used to track changes to a project and to help<br>
multiple people to collaborate on a project. At a basic level, a project version<br>
controlled by Git consists of a folder with files in it, and Git tracks the changes<br>
that are made to the files in the project. This allows you to save different<br>
versions of the work you’re doing, which is why we call Git a version control<br>
system.<br>git commit -m ""<br>
-m -&gt; option<br>
 -&gt; argument<br>
options are denoted by - or --<br>pwd - print working directory<br>Commands<br>
git config --global  --list : list the variables in the global git configuration file and their values<br>
it will show information of the global git configuration file -&gt; usually .gitconfig file<br><img alt="image1.png" src="git/image1.png"><br>Variables we are interested in are: user.email and user.name. Every time someone saves a version of their project(i.e commits), Git will note down the name and email address of the individual and associate it with that saved version.The user.name and user.email variables<br>
are used to set the name and email address that will be saved for the commits<br>
you make. This means that you can see who worked on what in a Git project.<br>To set these variables in your global Git configuration file, you pass them as<br>
arguments to the git config command, entering your desired values inside<br>
quotation marks.<br><img alt="image2.png" src="git/image2.png"><br>Text editor - Program that allows a user to edit plain text.<br>
Some advanced text editors like VS Code ~ IDEs (Integrated Development Environment) come with integrated terminal, in which you can execute the commands you would normally use in your command line window.]]></description><link>git/chapter-one.html</link><guid isPermaLink="false">git/Chapter one.md</guid><pubDate>Sun, 09 Jun 2024 12:28:13 GMT</pubDate><enclosure url="git/image1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="git/image1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Seven - Creating and Pushing to a Remote Repository]]></title><description><![CDATA[ 
 <br>STARTING FROM A LOCAL REPOSITORY<br>
To start to work on a Git project from a local repository, you must first create a<br>
local repository on a computer using the git init command and make at least<br>
one commit. Next, you must create a remote repository on a hosting service.<br>
Finally, you may upload data from the local repository to the remote repository.<br>
In Git, we use the term push or pushing to refer to the process of uploading data<br>
from a local repository to a remote repository, and the command we use to do<br>
this is git push.<br><img alt="Pasted image 20240712151008.png" src="git/pasted-image-20240712151008.png"><br>Local repositories and remote repositories act separately. When it comes to<br>
working with them, it’s important to understand that no interaction between them<br>
happens automatically. In other words, no updates from the local repository to<br>
the remote repository will happen automatically, and conversely, no updates<br>
from the remote repository to the local repository will happen automatically.<br>
There is no live connection between the two. Any changes in either will be the<br>
result of you explicitly executing commands. In this and the following chapters,<br>
you will learn what these commands are<br>Why Do We Use Remote Repositories?<br>
There are three main reasons why remote repositories are useful and important<br>
when working on a Git project. They allow you to:<br>
• Easily back up your project somewhere other than your computer.<br>
• Access a Git project from multiple computers.<br>
• Collaborate with others on Git projects.<br>If a local repository was initialized locally, to set up a connection to a remote<br>
repository you must explicitly associate the remote repository URL to the remote<br>
repository shortname. To do this you use the git remote add command, passing<br>
in the shortname followed by the remote repository URL.<br><img alt="Pasted image 20240712171215.png" src="git/pasted-image-20240712171215.png"><br><img alt="Pasted image 20240712171307.png" src="git/pasted-image-20240712171307.png"><br>In the official Git documentation, a connection to a remote repository stored in a local<br>
repository is simply referred to as a remote<br>To see the list of connections to remote repositories stored in a local repository<br>
by shortname, you may use the git remote command. If you pass in the -v<br>
option (which stands for “verbose”) to the git remote command, then it lists the<br>
connections to remote repositories stored in a local repository by shortname<br>
along with their URLs.<br><img alt="Pasted image 20240712171545.png" src="git/pasted-image-20240712171545.png"><br><img alt="Pasted image 20240712171658.png" src="git/pasted-image-20240712171658.png"><br><img alt="Pasted image 20240712184557.png" src="git/pasted-image-20240712184557.png"><br>• The rainbow repository has a shortname associated with the remote<br>
repository URL, called origin.<br>
• The rainbow-remote repository still does not have any data in it.<br>You can see that the arrow that represents the shortname<br>
stored in the rainbow repository that relates to the rainbow-remote repository is<br>
going in only one direction. This is because the connection between a local and a<br>
remote repository goes from the local repository to the remote repository but not<br>
the other way around. In a local repository, you can find a list of all the remote<br>
repositories it has stored a connection to; however, in a remote repository you<br>
cannot find a list of local repositories that store a connection to that remote<br>
repository.<br>Notice as well that just because you added a connection to the remote repository<br>
in your local repository does not mean that any data from the local repository<br>
was uploaded to the remote repository. To upload data to a remote repository,<br>
you must push a branch to the remote repository. This process will upload all the<br>
commits that are part of that branch<br>In Chapter 4 you learned about branches, which as you saw are movable pointers<br>
to commits. Up until now, you have worked only with local branches. When you<br>
push a local branch to a remote repository, you will create a remote branch. A<br>
remote branch is a branch in a remote repository.<br>Remote branches do not automatically update when you make more commits on<br>
local branches. You have to explicitly push commits from a local branch to a<br>
remote branch. Every remote branch (that a local repository knows about) also<br>
has a remote-tracking branch. This is a reference in a local repository to the<br>
commit a remote branch pointed at the last time any network communication<br>
happened with the remote repository. You can think of it as being like a<br>
bookmark<br>You can set up a tracking relationship between a local branch and a remote<br>
branch by defining which remote branch a local branch should track. This is<br>
referred to as the upstream branch. There are some cases where Git will set the<br>
upstream branch automatically, but in other cases you have to set it explicitly.<br>When you push work from a local branch to a remote branch, Git needs to know<br>
which remote branch you want to push to. If the local branch has an upstream<br>
branch defined for it, you can use git push with no arguments, and Git will<br>
automatically push the work to that branch. However, if no upstream branch is<br>
defined for the local branch you’re working on, you’ll need to specify which<br>
remote branch to push to when you enter the git push command<br>To push a local branch to your remote repository, you will use the git push<br>
command and pass in the shortname for the remote repository and the name of<br>
the branch that you want to push. For the rainbow repository, the shortname you<br>
will use is origin and the branch you will push is main.<br><img alt="Pasted image 20240712185501.png" src="git/pasted-image-20240712185501.png"><br>After you execute the git push command, two things will happen:<br>
<br>A remote branch will be created in your remote repository.
<br>A remote-tracking branch will be created in your local repository
<br>To push data to a remote repository, you must be connected to the internet and have either<br>
SSH access or HTTPS access to your hosting service of choice.<br><img alt="Pasted image 20240712185757.png" src="git/pasted-image-20240712185757.png"><br><img alt="Pasted image 20240712190519.png" src="git/pasted-image-20240712190519.png"><br><img alt="Pasted image 20240712190538.png" src="git/pasted-image-20240712190538.png"><br>4]]></description><link>git/chapter-seven-creating-and-pushing-to-a-remote-repository.html</link><guid isPermaLink="false">git/Chapter Seven - Creating and Pushing to a Remote Repository.md</guid><pubDate>Fri, 12 Jul 2024 19:07:29 GMT</pubDate><enclosure url="git/pasted-image-20240712151008.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="git/pasted-image-20240712151008.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Six - Hosting Services and Authentication]]></title><description><![CDATA[ 
 <br> two types of repositories: local repositories and remote<br>
repositories. Local repositories are found on a computer, while remote<br>
repositories are hosted on a hosting service in the cloud.<br>To transfer data between a local repository and a remote repository on a hosting<br>
service, you must connect and authenticate using either SSH or HTTPS<br>The HTTPS protocol uses a username and some sort of password (or<br>
authentication credential) to allow you to securely connect to remote<br>
repositories. In the past, all the hosting services allowed you to use the password<br>
you use to log in to your account on the hosting service (which we will refer to<br>
as the account password) for HTTPS authentication as well. However, GitHub<br>
and Bitbucket no longer allow this; they require you to create another<br>
authentication credential.<br>
In GitHub, the authentication credential is called a personal access token. In<br>
Bitbucket, it’s called an app password. With GitLab, you can still simply use<br>
your account password to authenticate. See Table 6-1 for an overview of the<br>
three most common hosting services and the access credentials necessary to<br>
authenticate over HTTPS<br>Setting up HTTPS: <a rel="noopener" class="external-link" href="https://github.com/gitlearningjourney/learning-git" target="_blank">https://github.com/gitlearningjourney/learning-git</a><br>USING SSH<br>
The SSH protocol uses a public and private SSH key pair to allow you to<br>
securely connect to remote repositories. The three main steps to setting up SSH<br>
access are:<br>
<br>Create an SSH key pair on your computer.
<br>Add the private SSH key to the SSH agent.
<br>Add the public SSH key to the hosting service account.
<br>Setting up SSH: <a rel="noopener" class="external-link" href="https://github.com/gitlearningjourney/learning-git" target="_blank">https://github.com/gitlearningjourney/learning-git</a>]]></description><link>git/chapter-six-hosting-services-and-authentication.html</link><guid isPermaLink="false">git/Chapter Six - Hosting Services and Authentication.md</guid><pubDate>Fri, 12 Jul 2024 09:07:49 GMT</pubDate></item><item><title><![CDATA[Chapter Three]]></title><description><![CDATA[ 
 <br>COMMIT EARLY, COMMIT OFTEN<br>git status - Tells you the state of the working directory and the staging area, this is useful because in a project with many files it is easy to lose track of what state the files in your working directory are in and which files you've added to the staging area.<br>In a project with many files, it can be hard to remember which files are untracked, which files are tracked, and which files you’ve edited. <br>Example Book Project 3-1<br>
The Book project I’m working on consists of 10 files, one for each chapter in the book. After working on the book for a while in between commits, I may forget which chapter files I have edited. I know I worked on chapters 2 and 3, but did I make any changes in chapter 4? If so, I don’t want to lose them.<br>
In this case, the git status command can help me by telling me which<br>
chapter files I’ve edited, which ones I’ve added to the staging area, and which ones I have yet to add.<br><img alt="Pasted image 20240610222102.png" src="git/pasted-image-20240610222102.png"><br><img alt="Pasted image 20240610222148.png" src="git/pasted-image-20240610222148.png"><br>
rainbow project<br>** No commits yet- The commit history doesn't have any commits at this point of time.<br><img alt="Pasted image 20240610222416.png" src="git/pasted-image-20240610222416.png"><br>The staging area allows you to choose which updated files (or changes) will be included in your next commit. The general rule is to group related changes together. This allows you to keep your commits more organized.<br>This first step of the committing process allows you to be very specific about what you include in a commit. This means that you can edit many files in your project, but you don’t have to save them all in one commit.<br>In the Rainbow project, the rainbowcolors.txt file is the first file you will add<br>
to the staging area. This means that when you add this file, the index file (which<br>
represents the staging area in the .git directory) will be created. As you learned<br>
in Chapter 2, this file does not exist until you add a file to the staging area.The<br>
index file is a binary file, which means the actual contents look like gibberish to<br>
a human and are not easily understandable. For our purposes, we only need to<br>
understand that it represents the staging area.<br><img alt="Pasted image 20240610230007.png" src="git/pasted-image-20240610230007.png"><br><img alt="Pasted image 20240610230047.png" src="git/pasted-image-20240610230047.png"><br>The rainbowcolors.txt file is now both in the working directory and in the<br>
staging area. This is because the git add command does not move a file from<br>
the working directory to the staging area. It copies the file from the working<br>
directory into the staging area.<br><img alt="Pasted image 20240610230131.png" src="git/pasted-image-20240610230131.png"><br>Upon running git add rainbowcolours.txt git commit -m "Red"<br>
<img alt="Pasted image 20240610230458.png" src="git/pasted-image-20240610230458.png"><br>The output of the git commit command shows the first seven characters of<br>
the commit hash for the red commit, which is c26d0bc in this book. The<br>
first seven characters of your commit hash will be different.<br><img alt="Pasted image 20240610230557.png" src="git/pasted-image-20240610230557.png"><br>Viewing a List of Commits<br>
To see a list of commits in the commit history, you use the git log command.<br>
The git log command lists the commits in a local repository in reverse<br>
chronological order. It displays four pieces of information about each commit:<br>
<br>Commit hash
<br>Author name and email address
<br>Date and time commit was made
<br>Commit message
<br><img alt="Pasted image 20240610230812.png" src="git/pasted-image-20240610230812.png">]]></description><link>git/chapter-three.html</link><guid isPermaLink="false">git/Chapter Three.md</guid><pubDate>Mon, 10 Jun 2024 17:38:14 GMT</pubDate><enclosure url="git/pasted-image-20240610222102.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="git/pasted-image-20240610222102.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Chapter Two]]></title><description><![CDATA[ 
 <br>Repository/ repo is how we refer to a project version controlled by GIt.<br>
Two types of repos:<br>
-Local repo: Stored on a computer<br>
-Remote repo: Hosted on a hosting service<br>Hosting service: Companies that provide hosting for projects using Git. Eg: GitHub, GitLab, BitBucket<br>A local repository is represented by a hidden directory called .git that exists<br>
within a project directory. It contains all the data on the changes that have been<br>
made to the files in a project.<br>
To turn a project directory into a local repository you have to initialize, or create,<br>
the repository. When you initialize a repository, the .git directory is<br>
automatically created inside the project directory. Because the .git directory is a<br>
hidden directory, you won’t be able to see it unless you explicitly make hidden<br>
files and directories visible.<br>Normally we initialize a Git repo using git init command, with no additional options; however, in the rainbow project(/dev/oreilly/learning-git/rainbow), we wil use  git init -b where -b stands for --initiali-branch and pass in the name main(argument).<br>Hence, git init -b main<br>By default Git will create a branch called master when you initialize a new<br>
local repository. From Git version 2.28 onwards, the name of the initial branch is<br>
configurable. I have chosen to use the name main instead of master in this book,<br>
because “master” is not considered inclusive terminology.<br><img alt="image3.png" src="git/image3.png"><br>Running the command: git init -b main* in the rainbow repo*<br><img alt="image4.png" src="git/image4.png"><br>
The contents of .git repo right after running git init command<br>Four important areas to be aware of when working with Git:<br>
- Working directory<br>
- Staging area<br>
-  Commit History<br>
-  Local repository<br>Introduction to Working Directory:
	The working directory contains the files and directories in the project directorythat represent one version of a project. It is sort of like a workbench. It is where you add, edit, and delete files and directories.

	![[workingDirectory.png]]
	

Introduction to the Staging Area:
	The staging area is similar to a rough draft space. It is where you can add and remove files, when you are preparing what you want to include in the next saved version of your project (your next commit). The staging area is represented by a file in the .git directory called index.

	![[stagingArea.png]]
	

What is a Commit ?
	A Commit in Git is basically one version of a project.
	Every commit has a commit hash (sometimes called a commit ID). This is a unique 40-character hash composed of letters and numbers that acts like a name for the commit, providing a way to refer to it. An example of a commit hash is 51dc6ecb327578cca503abba4a56e8c18f3835e1. In reality, you only need the first seven characters of a commit hash to refer to a commit. So, for the example hash just given, you can just use 51dc6ec to refer to the commit.

Introducing the Commit History
	The commit history is where you can think of your commits existing. It is represented by the objects directory inside the .git directory.

	![[commitHistory.png]]
Copy<br><img alt="rainbowColors.png" src="git/rainbowcolors.png"><br>Since the rainbowcolors.txt file is not yet in your repository, it is an untracked<br>
file. An untracked file is a file in the working directory that Git is not version<br>
controlling. It has never been added to the staging area and it has never been<br>
included in a commit; therefore, it is not part of the repository.<br>
Once you add a file to the staging area and include it in a commit, the file<br>
becomes a tracked file. This is a file that is version controlled (in other words, a<br>
file that Git tracks).<br>
Every new file in a project version controlled by Git needs to be explicitly added<br>
to the staging area and then included in a commit in order to become a tracked<br>
file.]]></description><link>git/chapter-two.html</link><guid isPermaLink="false">git/Chapter Two.md</guid><pubDate>Sun, 09 Jun 2024 12:45:02 GMT</pubDate><enclosure url="git/image3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="git/image3.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Git Index]]></title><description><![CDATA[ 
 <br><a data-href="Chapter one" href="git/chapter-one.html" class="internal-link" target="_self" rel="noopener">Chapter one</a><br>
<a data-href="Chapter Two" href="git/chapter-two.html" class="internal-link" target="_self" rel="noopener">Chapter Two</a><br>
<a data-href="Chapter Three" href="git/chapter-three.html" class="internal-link" target="_self" rel="noopener">Chapter Three</a><br>
<a data-href="Chapter Four" href="git/chapter-four.html" class="internal-link" target="_self" rel="noopener">Chapter Four</a><br>
<a data-href="Chapter Five - Merging" href="git/chapter-five-merging.html" class="internal-link" target="_self" rel="noopener">Chapter Five - Merging</a><br>
<a data-href="Chapter Six - Hosting Services and Authentication" href="git/chapter-six-hosting-services-and-authentication.html" class="internal-link" target="_self" rel="noopener">Chapter Six - Hosting Services and Authentication</a><br>
<a data-href="Chapter Seven - Creating and Pushing to a Remote Repository" href="git/chapter-seven-creating-and-pushing-to-a-remote-repository.html" class="internal-link" target="_self" rel="noopener">Chapter Seven - Creating and Pushing to a Remote Repository</a>]]></description><link>git/git-index.html</link><guid isPermaLink="false">git/Git Index.md</guid><pubDate>Fri, 26 Jul 2024 13:36:51 GMT</pubDate></item></channel></rss>